{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 HelveticaNeue-Italic;
}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs32 \cf0 \cb2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Programming assignments:
\f1\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Write a simple filter to clean a text, i.e. to remove all characters that are not alphabetic, blank or newline - replacing every such character by a blank to keep the number of characters constant to the original text. Hint: this is easy to do in C using the "isalpha()" function (to find out more about it on a unix/linux system type:\'a0
\f2\i man isalpha
\f1\i0 \'a0as a command to the shell) This could be useful for the next assignments. A filter is a program which reads its input from\'a0
\f2\i stdin
\f1\i0 , processes it and the prints the result to\'a0
\f2\i stdout\'a0
\f1\i0 (i.e. reads and writes from/to the terminal).\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Use the first thousand words from\'a0
\f2\i the text
\f1\i0 \'a0to measure the running time of the ordered array ST (also known as binary search symbol table, see algorithm 3.2 in the book (obs not chapter 3.2)). Use the FrequencyCounter from page 372 as test program (you may need to change how you read the words if you do not use the libraries from Sedgewick&Wayne). Show tables or graphs of your measurements.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Use the first thousand words from\'a0
\f2\i the text
\f1\i0 \'a0to measure the running time of the Binary Search Tree algorithm (Algorithm 3.3 in the book (obs not chapter 3.3)) (you need only implement the basic operations to put and get keys to/from the ST) Use the FrequencyCounter from page 372 as test program (you may need to change how you read the words if you do not use the libraries from Sedgewick&Wayne). Show tables or graphs of your measurements.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	4	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Compare and explain the differences in execution time of the two algorithms in assignments 2 and 3.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	5	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Write a program that shows how evenly the built-in hashcode() function for strings in Java distributes the hashcodes for the words found in the text. (Hint it may be hard to use the hashcodes directly without manipulating them...)\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	6	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Write a program which allows the user to repeatedly ask questions (without re-reading the text or re-building the data structures used) how many times a word occurs in the text. Base the implementation on a hash table which uses separate chaining.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	7	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Write a program based on a Binary Search Tree which reads the first two hundred words from the text and allows the user to select to print these words in either alphabetic or reverse alphabetic order. The printing of the content of the tree should be done in a method while traversing the tree. The time complexity of the printing should be O(N) where N is the number of different words in the text and the memory complexity should be O(log(N)) assuming the tree is balanced.\cb1 \
}