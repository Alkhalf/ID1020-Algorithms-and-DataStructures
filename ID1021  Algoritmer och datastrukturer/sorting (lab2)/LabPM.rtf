{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 HelveticaNeue-Italic;
}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs32 \cf0 \cb2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Programming assignments:
\f1\b0 \
Basis for assignments 1 and 2: Implement insertionsort. Augment the sorting process so that all the content of the array that is being sorted is printed after each inner loop iteration. Write a unit test in main() which allows the user to define the size of the input (N) and then input (N) integers from stdin which is to be sorted.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Augment the above implementation so that it prints the number of swaps performed when sorting the array.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Add a method which counts the number of inversions in the input array and prints a list of all inversions on the format [i,a[i]], [j, a[j]] where i and j are indices and a[i], a[j] are the values of the elements. Call the method from main() before the array is sorted. Calculate the time complexity for the algorithm.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Implement a function in C which takes an array of integers (both positive and negative) and orders the elements in the array so that all negative elements come before the positive. You are not allowed to sort the array (i.e. by any of the sorting methods) - only collect all negative values first. The algorithm should only use O(1) extra memory (i.e. be in-place\'a0{\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/In-place_algorithm"}}{\fldrslt \ul Wikipedia: In-place algorithm\'a0(L\'e4nkar till en externa sida.)\cb1 \ulnone \uc0\u8232 \cb2 \ul L\'e4nkar till en externa sida.\cb1 \ulnone \uc0\u8232 }})\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	4	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Compare the execution times for sorting large arrays of integers with insertionsort, merge sort and quicksort. When should one select one method over the others? Upload code, tests and a graphs depicting the execution times as a function of input (what parameters in the input could be relevant?). (you need to test for a range of input sizes)\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	5	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Experiment with the cut-off to insertionsort in mergesort. How is the execution time affected by different values for the cut-off? A suitable range for cut-off values to test with could be [0-30]. Upload code, tests and a graphs.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	6	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Compare the execution times of quicksort where the first element in each sub-array is selected as partitioning element to that of quicksort with median-of-three partitioning\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	7	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 Augment the test code from assignment 1&2 so that the array is sorted in descending order instead of ascending order (you may add O(N) operations)\'a0
\f2\i\fs24 Clarification: You should not change (not alter/modify any code in) the sorting method, nor should you sort the array an extra time. You may traverse the array once before sorting and once after sorting. During these traversals you may not move (re-order) any elements. (Hint: you need not and should not use any extra memory)
\f1\i0\fs32 \cb1 \
}